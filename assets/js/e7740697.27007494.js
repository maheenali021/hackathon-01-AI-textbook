"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[376],{6708:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module3/nav2-path-planning","title":"Chapter 3: Navigation2 Path Planning and Execution","description":"Introduction to Navigation2","source":"@site/docs/module3/nav2-path-planning.md","sourceDirName":"module3","slug":"/module3/nav2-path-planning","permalink":"/hackathon-01-AI-textbook/docs/module3/nav2-path-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/maheenali021/hackathon-01-AI-textbook/tree/main/docs/module3/nav2-path-planning.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Chapter 3: Navigation2 Path Planning and Execution"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2: Isaac ROS","permalink":"/hackathon-01-AI-textbook/docs/module3/isaac-ros"},"next":{"title":"Module 3 Milestone Project: Isaac ROS Perception Pipeline","permalink":"/hackathon-01-AI-textbook/docs/module3/module3-milestone"}}');var a=r(4848),o=r(8453);const i={sidebar_position:3,title:"Chapter 3: Navigation2 Path Planning and Execution"},s="Navigation2 Path Planning and Execution",l={},c=[{value:"Introduction to Navigation2",id:"introduction-to-navigation2",level:2},{value:"Navigation2 Architecture",id:"navigation2-architecture",level:2},{value:"Core Components",id:"core-components",level:3},{value:"Parameter Configuration",id:"parameter-configuration",level:3},{value:"Global Path Planning",id:"global-path-planning",level:2},{value:"NavFn Planner",id:"navfn-planner",level:3},{value:"Local Path Following",id:"local-path-following",level:2},{value:"Controller Implementation",id:"controller-implementation",level:3},{value:"Navigation Actions and Services",id:"navigation-actions-and-services",level:2},{value:"Navigation Action Client",id:"navigation-action-client",level:3},{value:"Obstacle Avoidance",id:"obstacle-avoidance",level:2},{value:"Local Planner with Obstacle Avoidance",id:"local-planner-with-obstacle-avoidance",level:3},{value:"Recovery Behaviors",id:"recovery-behaviors",level:2},{value:"Recovery Actions",id:"recovery-actions",level:3},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Hands-on Exercise",id:"hands-on-exercise",level:2}];function _(n){const e={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"navigation2-path-planning-and-execution",children:"Navigation2 Path Planning and Execution"})}),"\n",(0,a.jsx)(e.h2,{id:"introduction-to-navigation2",children:"Introduction to Navigation2"}),"\n",(0,a.jsx)(e.p,{children:"Navigation2 is the official navigation framework for ROS 2, providing path planning, obstacle avoidance, and navigation execution capabilities for mobile robots. It builds upon the lessons learned from ROS 1's navigation stack with improved architecture and performance."}),"\n",(0,a.jsx)(e.h2,{id:"navigation2-architecture",children:"Navigation2 Architecture"}),"\n",(0,a.jsx)(e.h3,{id:"core-components",children:"Core Components"}),"\n",(0,a.jsx)(e.p,{children:"Navigation2 follows a modular architecture with several key components:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Lifecycle Manager"}),": Manages the lifecycle of navigation components"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Local Planner"}),": Handles local path following and obstacle avoidance"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Global Planner"}),": Computes global paths from start to goal"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Controller"}),": Executes trajectory following"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Recovery"}),": Handles navigation recovery behaviors"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"parameter-configuration",children:"Parameter Configuration"}),"\n",(0,a.jsx)(e.p,{children:"Navigation2 uses YAML configuration files to define behavior:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-yaml",children:"# bt_navigator_params.yaml\r\nbt_navigator:\r\n  ros__parameters:\r\n    global_frame: map\r\n    robot_base_frame: base_link\r\n    odom_topic: /odom\r\n    bt_loop_duration: 10\r\n    default_server_timeout: 20\r\n    enable_groot_monitoring: True\r\n    groot_zmq_publisher_port: 1666\r\n    groot_zmq_server_port: 1667\r\n    # Specify the path where the BT XML files are located\r\n    plugin_lib_names:\r\n    - nav2_compute_path_to_pose_action_bt_node\r\n    - nav2_follow_path_action_bt_node\r\n    - nav2_back_up_action_bt_node\r\n    - nav2_spin_action_bt_node\r\n    - nav2_wait_action_bt_node\r\n    - nav2_clear_costmap_service_bt_node\r\n    - nav2_is_stuck_condition_bt_node\r\n    - nav2_goal_reached_condition_bt_node\r\n    - nav2_goal_updated_condition_bt_node\r\n    - nav2_initial_pose_received_condition_bt_node\r\n    - nav2_reinitialize_global_localization_service_bt_node\r\n    - nav2_rate_controller_bt_node\r\n    - nav2_distance_controller_bt_node\r\n    - nav2_speed_controller_bt_node\r\n    - nav2_truncate_path_action_bt_node\r\n    - nav2_goal_updater_node_bt_node\r\n    - nav2_recovery_node_bt_node\r\n    - nav2_pipeline_sequence_bt_node\r\n    - nav2_round_robin_node_bt_node\r\n    - nav2_transform_available_condition_bt_node\r\n    - nav2_time_expired_condition_bt_node\r\n    - nav2_path_expiring_timer_condition\r\n    - nav2_distance_traveled_condition_bt_node\r\n    - nav2_single_trigger_bt_node\r\n    - nav2_is_battery_low_condition_bt_node\r\n    - nav2_navigate_to_pose_action_bt_node\r\n    - nav2_remove_passed_goals_action_bt_node\r\n    - nav2_planner_selector_bt_node\r\n    - nav2_controller_selector_bt_node\r\n    - nav2_goal_checker_selector_bt_node\n"})}),"\n",(0,a.jsx)(e.h2,{id:"global-path-planning",children:"Global Path Planning"}),"\n",(0,a.jsx)(e.h3,{id:"navfn-planner",children:"NavFn Planner"}),"\n",(0,a.jsx)(e.p,{children:"The NavFn planner computes global paths using the navigation function approach:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom nav_msgs.msg import OccupancyGrid, Path\r\nfrom geometry_msgs.msg import PoseStamped, Point\r\nfrom nav2_msgs.srv import GetCostmap\r\nimport numpy as np\r\n\r\nclass GlobalPathPlanner(Node):\r\n    def __init__(self):\r\n        super().__init__(\'global_path_planner\')\r\n\r\n        # Subscribers\r\n        self.map_sub = self.create_subscription(\r\n            OccupancyGrid, \'map\', self.map_callback, 10)\r\n\r\n        # Publishers\r\n        self.path_pub = self.create_publisher(Path, \'global_plan\', 10)\r\n\r\n        # Service client for costmap\r\n        self.costmap_client = self.create_client(GetCostmap, \'costmap/get_costmap\')\r\n\r\n        # Internal state\r\n        self.map_data = None\r\n        self.map_resolution = 0.05  # meters per pixel\r\n        self.origin = [0, 0, 0]  # x, y, theta\r\n\r\n        # Timer for path planning\r\n        self.path_timer = self.create_timer(0.5, self.plan_path_if_needed)\r\n\r\n    def map_callback(self, msg):\r\n        """Process incoming map data"""\r\n        self.map_data = msg\r\n        self.map_resolution = msg.info.resolution\r\n        self.origin = [\r\n            msg.info.origin.position.x,\r\n            msg.info.origin.position.y,\r\n            msg.info.origin.orientation.z  # Simplified\r\n        ]\r\n\r\n    def plan_path_if_needed(self):\r\n        """Plan path if needed"""\r\n        # This would normally be triggered by a navigation goal\r\n        pass\r\n\r\n    def compute_path(self, start, goal):\r\n        """Compute path using Dijkstra\'s algorithm (NavFn approach)"""\r\n        if not self.map_data:\r\n            return None\r\n\r\n        # Convert world coordinates to map indices\r\n        start_idx = self.world_to_map(start)\r\n        goal_idx = self.world_to_map(goal)\r\n\r\n        if not start_idx or not goal_idx:\r\n            return None\r\n\r\n        # Create costmap from occupancy grid\r\n        costmap = self.create_costmap_from_occupancy(self.map_data)\r\n\r\n        # Run path planning algorithm (simplified Dijkstra\'s)\r\n        path_indices = self.dijkstra_pathfinding(costmap, start_idx, goal_idx)\r\n\r\n        if path_indices:\r\n            # Convert path back to world coordinates\r\n            path = self.indices_to_path(path_indices)\r\n            return path\r\n\r\n        return None\r\n\r\n    def world_to_map(self, point):\r\n        """Convert world coordinates to map indices"""\r\n        if not self.map_data:\r\n            return None\r\n\r\n        x = int((point.x - self.map_data.info.origin.position.x) / self.map_data.info.resolution)\r\n        y = int((point.y - self.map_data.info.origin.position.y) / self.map_data.info.resolution)\r\n\r\n        # Check bounds\r\n        if x < 0 or x >= self.map_data.info.width or y < 0 or y >= self.map_data.info.height:\r\n            return None\r\n\r\n        return (y, x)  # Note: row, col (y, x)\r\n\r\n    def map_to_world(self, row, col):\r\n        """Convert map indices to world coordinates"""\r\n        x = col * self.map_data.info.resolution + self.map_data.info.origin.position.x\r\n        y = row * self.map_data.info.resolution + self.map_data.info.origin.position.y\r\n        return (x, y)\r\n\r\n    def create_costmap_from_occupancy(self, occupancy_grid):\r\n        """Create costmap from occupancy grid"""\r\n        width = occupancy_grid.info.width\r\n        height = occupancy_grid.info.height\r\n        data = occupancy_grid.data\r\n\r\n        # Reshape the 1D array to 2D\r\n        costmap = np.array(data).reshape(height, width)\r\n\r\n        # Convert occupancy values to costs\r\n        # Free space: 0, Occupied: 100, Unknown: -1\r\n        # In costmap: higher values mean higher cost\r\n        costmap_processed = np.copy(costmap)\r\n        costmap_processed[costmap_processed == -1] = 50  # Unknown space has medium cost\r\n        costmap_processed[costmap_processed == 0] = 0    # Free space has no cost\r\n        costmap_processed[costmap_processed > 0] = 100   # Occupied space has high cost\r\n\r\n        return costmap_processed\r\n\r\n    def dijkstra_pathfinding(self, costmap, start_idx, goal_idx):\r\n        """Simplified Dijkstra\'s algorithm for pathfinding"""\r\n        import heapq\r\n\r\n        height, width = costmap.shape\r\n        start_row, start_col = start_idx\r\n        goal_row, goal_col = goal_idx\r\n\r\n        # Directions: up, down, left, right, and diagonals\r\n        directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]\r\n        direction_costs = [1.414, 1.0, 1.414, 1.0, 1.0, 1.414, 1.0, 1.414]\r\n\r\n        # Priority queue: (cost, row, col)\r\n        pq = [(0, start_row, start_col)]\r\n        visited = set()\r\n        predecessors = {}\r\n\r\n        while pq:\r\n            cost, row, col = heapq.heappop(pq)\r\n\r\n            if (row, col) in visited:\r\n                continue\r\n\r\n            visited.add((row, col))\r\n\r\n            if (row, col) == (goal_row, goal_col):\r\n                # Found the goal, reconstruct path\r\n                return self.reconstruct_path(predecessors, start_idx, goal_idx)\r\n\r\n            # Explore neighbors\r\n            for i, (dr, dc) in enumerate(directions):\r\n                new_row, new_col = row + dr, col + dc\r\n\r\n                if (0 <= new_row < height and 0 <= new_col < width and\r\n                    (new_row, new_col) not in visited):\r\n\r\n                    # Calculate movement cost\r\n                    neighbor_cost = costmap[new_row, new_col]\r\n                    move_cost = direction_costs[i] * (1 + neighbor_cost / 100.0)\r\n                    total_cost = cost + move_cost\r\n\r\n                    if neighbor_cost < 90:  # Not heavily occupied\r\n                        if (new_row, new_col) not in [item[1:] for item in pq]:\r\n                            heapq.heappush(pq, (total_cost, new_row, new_col))\r\n                            predecessors[(new_row, new_col)] = (row, col)\r\n\r\n        return None  # No path found\r\n\r\n    def reconstruct_path(self, predecessors, start_idx, goal_idx):\r\n        """Reconstruct path from predecessors dictionary"""\r\n        path = [goal_idx]\r\n        current = goal_idx\r\n\r\n        while current != start_idx:\r\n            if current not in predecessors:\r\n                return None  # No path exists\r\n            current = predecessors[current]\r\n            path.append(current)\r\n\r\n        path.reverse()\r\n        return path\r\n\r\n    def indices_to_path(self, indices):\r\n        """Convert map indices to Path message"""\r\n        path_msg = Path()\r\n        path_msg.header.frame_id = \'map\'\r\n        path_msg.header.stamp = self.get_clock().now().to_msg()\r\n\r\n        for row, col in indices:\r\n            x, y = self.map_to_world(row, col)\r\n\r\n            pose = PoseStamped()\r\n            pose.header.frame_id = \'map\'\r\n            pose.pose.position.x = x\r\n            pose.pose.position.y = y\r\n            pose.pose.position.z = 0.0\r\n\r\n            # Simple orientation (pointing towards next point)\r\n            path_msg.poses.append(pose)\r\n\r\n        return path_msg\n'})}),"\n",(0,a.jsx)(e.h2,{id:"local-path-following",children:"Local Path Following"}),"\n",(0,a.jsx)(e.h3,{id:"controller-implementation",children:"Controller Implementation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'from geometry_msgs.msg import Twist, PoseStamped\r\nfrom nav_msgs.msg import Odometry\r\nfrom tf2_ros import TransformException\r\nfrom tf2_ros import Buffer, TransformListener\r\nimport math\r\n\r\nclass LocalController(Node):\r\n    def __init__(self):\r\n        super().__init__(\'local_controller\')\r\n\r\n        # Subscribers\r\n        self.odom_sub = self.create_subscription(\r\n            Odometry, \'odom\', self.odom_callback, 10)\r\n\r\n        self.path_sub = self.create_subscription(\r\n            Path, \'local_plan\', self.path_callback, 10)\r\n\r\n        # Publishers\r\n        self.cmd_vel_pub = self.create_publisher(Twist, \'cmd_vel\', 10)\r\n\r\n        # TF buffer for transforms\r\n        self.tf_buffer = Buffer()\r\n        self.tf_listener = TransformListener(self.tf_buffer, self)\r\n\r\n        # Robot state\r\n        self.current_pose = None\r\n        self.current_twist = None\r\n        self.current_path = []\r\n        self.path_index = 0\r\n\r\n        # Controller parameters\r\n        self.lookahead_distance = 0.5  # meters\r\n        self.linear_kp = 1.0\r\n        self.angular_kp = 2.0\r\n        self.max_linear_speed = 0.5\r\n        self.max_angular_speed = 1.0\r\n\r\n        # Timer for control loop\r\n        self.control_timer = self.create_timer(0.05, self.control_loop)  # 20 Hz\r\n\r\n    def odom_callback(self, msg):\r\n        """Process odometry data"""\r\n        self.current_pose = msg.pose.pose\r\n        self.current_twist = msg.twist.twist\r\n\r\n    def path_callback(self, msg):\r\n        """Process new path"""\r\n        self.current_path = msg.poses\r\n        self.path_index = 0  # Reset path index\r\n\r\n    def control_loop(self):\r\n        """Main control loop"""\r\n        if not self.current_pose or not self.current_path:\r\n            return\r\n\r\n        # Get current robot position\r\n        robot_x = self.current_pose.position.x\r\n        robot_y = self.current_pose.position.y\r\n\r\n        # Find next waypoint using pure pursuit\r\n        target_point = self.find_lookahead_point(robot_x, robot_y)\r\n\r\n        if target_point:\r\n            # Calculate control commands\r\n            cmd_vel = self.pure_pursuit_control(robot_x, robot_y, target_point)\r\n\r\n            # Publish command\r\n            self.cmd_vel_pub.publish(cmd_vel)\r\n        else:\r\n            # Stop if no target point found (end of path)\r\n            stop_cmd = Twist()\r\n            self.cmd_vel_pub.publish(stop_cmd)\r\n\r\n    def find_lookahead_point(self, robot_x, robot_y):\r\n        """Find point on path at lookahead distance"""\r\n        if len(self.current_path) <= self.path_index:\r\n            return None\r\n\r\n        # Look for point at lookahead distance\r\n        for i in range(self.path_index, len(self.current_path)):\r\n            pose = self.current_path[i].pose\r\n            path_x = pose.position.x\r\n            path_y = pose.position.y\r\n\r\n            distance = math.sqrt((path_x - robot_x)**2 + (path_y - robot_y)**2)\r\n\r\n            if distance >= self.lookahead_distance:\r\n                self.path_index = i  # Update path index\r\n                return (path_x, path_y)\r\n\r\n        # If no point found at lookahead distance, return the last point\r\n        if self.current_path:\r\n            last_pose = self.current_path[-1].pose\r\n            return (last_pose.position.x, last_pose.position.y)\r\n\r\n        return None\r\n\r\n    def pure_pursuit_control(self, robot_x, robot_y, target_point):\r\n        """Pure pursuit path following algorithm"""\r\n        target_x, target_y = target_point\r\n\r\n        # Calculate errors\r\n        dx = target_x - robot_x\r\n        dy = target_y - robot_y\r\n\r\n        # Calculate robot heading from orientation\r\n        robot_yaw = self.get_robot_yaw()\r\n\r\n        # Transform target point to robot frame\r\n        local_x = dx * math.cos(robot_yaw) + dy * math.sin(robot_yaw)\r\n        local_y = -dx * math.sin(robot_yaw) + dy * math.cos(robot_yaw)\r\n\r\n        # Calculate curvature (steering angle)\r\n        if local_x != 0:\r\n            curvature = 2 * local_y / (local_x**2 + local_y**2)\r\n        else:\r\n            curvature = 0\r\n\r\n        # Calculate linear velocity based on curvature (slow down when turning)\r\n        linear_vel = self.max_linear_speed * (1 - abs(curvature) * 0.5)\r\n        linear_vel = max(0.1, min(linear_vel, self.max_linear_speed))  # Clamp\r\n\r\n        # Calculate angular velocity\r\n        angular_vel = self.angular_kp * curvature\r\n        angular_vel = max(-self.max_angular_speed, min(angular_vel, self.max_angular_speed))\r\n\r\n        # Create command\r\n        cmd_vel = Twist()\r\n        cmd_vel.linear.x = linear_vel\r\n        cmd_vel.angular.z = angular_vel\r\n\r\n        return cmd_vel\r\n\r\n    def get_robot_yaw(self):\r\n        """Extract yaw from robot orientation quaternion"""\r\n        if not self.current_pose:\r\n            return 0.0\r\n\r\n        orientation = self.current_pose.orientation\r\n        siny_cosp = 2 * (orientation.w * orientation.z + orientation.x * orientation.y)\r\n        cosy_cosp = 1 - 2 * (orientation.y * orientation.y + orientation.z * orientation.z)\r\n        return math.atan2(siny_cosp, cosy_cosp)\n'})}),"\n",(0,a.jsx)(e.h2,{id:"navigation-actions-and-services",children:"Navigation Actions and Services"}),"\n",(0,a.jsx)(e.h3,{id:"navigation-action-client",children:"Navigation Action Client"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'from rclpy.action import ActionClient\r\nfrom rclpy.node import Node\r\nfrom nav2_msgs.action import NavigateToPose\r\nfrom geometry_msgs.msg import PoseStamped\r\nimport time\r\n\r\nclass NavigationClient(Node):\r\n    def __init__(self):\r\n        super().__init__(\'navigation_client\')\r\n\r\n        # Create action client\r\n        self._action_client = ActionClient(\r\n            self,\r\n            NavigateToPose,\r\n            \'navigate_to_pose\')\r\n\r\n    def send_goal(self, x, y, theta):\r\n        """Send navigation goal to Navigation2"""\r\n        # Wait for action server\r\n        self._action_client.wait_for_server()\r\n\r\n        # Create goal message\r\n        goal_msg = NavigateToPose.Goal()\r\n        goal_msg.pose.header.frame_id = \'map\'\r\n        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()\r\n        goal_msg.pose.pose.position.x = x\r\n        goal_msg.pose.pose.position.y = y\r\n        goal_msg.pose.pose.position.z = 0.0\r\n\r\n        # Convert angle to quaternion\r\n        goal_msg.pose.pose.orientation.z = math.sin(theta / 2.0)\r\n        goal_msg.pose.pose.orientation.w = math.cos(theta / 2.0)\r\n\r\n        # Send goal\r\n        self.get_logger().info(f\'Sending navigation goal to ({x}, {y}, {theta})\')\r\n        send_goal_future = self._action_client.send_goal_async(\r\n            goal_msg,\r\n            feedback_callback=self.feedback_callback)\r\n\r\n        # Add done callback\r\n        send_goal_future.add_done_callback(self.goal_response_callback)\r\n\r\n    def goal_response_callback(self, future):\r\n        """Handle goal response"""\r\n        goal_handle = future.result()\r\n        if not goal_handle.accepted:\r\n            self.get_logger().info(\'Goal rejected\')\r\n            return\r\n\r\n        self.get_logger().info(\'Goal accepted\')\r\n        get_result_future = goal_handle.get_result_async()\r\n        get_result_future.add_done_callback(self.get_result_callback)\r\n\r\n    def feedback_callback(self, feedback_msg):\r\n        """Handle feedback during navigation"""\r\n        feedback = feedback_msg.feedback\r\n        self.get_logger().info(f\'Current pose: {feedback.current_pose.pose.position.x:.2f}, {feedback.current_pose.pose.position.y:.2f}\')\r\n\r\n    def get_result_callback(self, future):\r\n        """Handle navigation result"""\r\n        result = future.result().result\r\n        self.get_logger().info(f\'Navigation result: {result}\')\n'})}),"\n",(0,a.jsx)(e.h2,{id:"obstacle-avoidance",children:"Obstacle Avoidance"}),"\n",(0,a.jsx)(e.h3,{id:"local-planner-with-obstacle-avoidance",children:"Local Planner with Obstacle Avoidance"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'from sensor_msgs.msg import LaserScan\r\nfrom geometry_msgs.msg import Twist\r\n\r\nclass ObstacleAvoidanceController(Node):\r\n    def __init__(self):\r\n        super().__init__(\'obstacle_avoidance_controller\')\r\n\r\n        # Subscribers\r\n        self.scan_sub = self.create_subscription(\r\n            LaserScan, \'scan\', self.scan_callback, 10)\r\n        self.cmd_sub = self.create_subscription(\r\n            Twist, \'cmd_vel\', self.cmd_callback, 10)\r\n\r\n        # Publishers\r\n        self.avoid_cmd_pub = self.create_publisher(Twist, \'cmd_vel_avoid\', 10)\r\n\r\n        # Internal state\r\n        self.current_scan = None\r\n        self.base_cmd = Twist()\r\n        self.safety_distance = 0.5  # meters\r\n\r\n    def scan_callback(self, msg):\r\n        """Process laser scan data"""\r\n        self.current_scan = msg\r\n\r\n    def cmd_callback(self, msg):\r\n        """Process base velocity commands"""\r\n        self.base_cmd = msg\r\n\r\n    def detect_obstacles(self):\r\n        """Detect obstacles in the path"""\r\n        if not self.current_scan:\r\n            return None\r\n\r\n        # Get ranges in front of the robot (\xb130 degrees)\r\n        front_ranges = self.get_front_ranges()\r\n\r\n        # Find minimum distance in front\r\n        min_distance = min(front_ranges) if front_ranges else float(\'inf\')\r\n\r\n        return min_distance\r\n\r\n    def get_front_ranges(self):\r\n        """Get laser ranges in front of robot (+/- 30 degrees)"""\r\n        if not self.current_scan:\r\n            return []\r\n\r\n        # Calculate indices for front sector\r\n        angle_min = self.current_scan.angle_min\r\n        angle_increment = self.current_scan.angle_increment\r\n        angle_max = self.current_scan.angle_max\r\n\r\n        # Front sector: -30 to +30 degrees\r\n        start_angle = -math.pi / 6  # -30 degrees\r\n        end_angle = math.pi / 6     # +30 degrees\r\n\r\n        start_idx = int((start_angle - angle_min) / angle_increment)\r\n        end_idx = int((end_angle - angle_min) / angle_increment)\r\n\r\n        # Clamp indices\r\n        start_idx = max(0, start_idx)\r\n        end_idx = min(len(self.current_scan.ranges), end_idx)\r\n\r\n        return self.current_scan.ranges[start_idx:end_idx]\r\n\r\n    def obstacle_avoidance_control(self):\r\n        """Apply obstacle avoidance to base commands"""\r\n        min_distance = self.detect_obstacles()\r\n\r\n        if min_distance is None:\r\n            return self.base_cmd\r\n\r\n        # If obstacle is too close, modify the command\r\n        if min_distance < self.safety_distance:\r\n            # Reduce forward speed proportionally to distance\r\n            reduction_factor = min_distance / self.safety_distance\r\n            avoid_cmd = Twist()\r\n            avoid_cmd.linear.x = self.base_cmd.linear.x * reduction_factor\r\n            avoid_cmd.angular.z = self.base_cmd.angular.z\r\n\r\n            # If very close, add evasive maneuver\r\n            if min_distance < self.safety_distance * 0.5:\r\n                # Check which side has more space\r\n                left_free = self.check_side_free(\'left\')\r\n                right_free = self.check_side_free(\'right\')\r\n\r\n                if left_free > right_free:\r\n                    avoid_cmd.angular.z += 0.5  # Turn left\r\n                else:\r\n                    avoid_cmd.angular.z -= 0.5  # Turn right\r\n\r\n            return avoid_cmd\r\n\r\n        return self.base_cmd\r\n\r\n    def check_side_free(self, side):\r\n        """Check free space on left or right side"""\r\n        if not self.current_scan:\r\n            return 0\r\n\r\n        ranges = self.current_scan.ranges\r\n        mid_idx = len(ranges) // 2\r\n\r\n        if side == \'left\':\r\n            # Check left side (first quarter of ranges)\r\n            side_ranges = ranges[:mid_idx//2]\r\n        else:  # right\r\n            # Check right side (last quarter of ranges)\r\n            side_ranges = ranges[mid_idx + mid_idx//2:]\r\n\r\n        if side_ranges:\r\n            return min([r for r in side_ranges if not math.isinf(r) and not math.isnan(r)] or [0])\r\n\r\n        return 0\n'})}),"\n",(0,a.jsx)(e.h2,{id:"recovery-behaviors",children:"Recovery Behaviors"}),"\n",(0,a.jsx)(e.h3,{id:"recovery-actions",children:"Recovery Actions"}),"\n",(0,a.jsx)(e.p,{children:"Navigation2 includes various recovery behaviors:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"from rclpy.action import ActionServer\r\nfrom rclpy.node import Node\r\nfrom nav2_msgs.action import BackUp, Spin, Wait\r\nimport time\r\n\r\nclass RecoveryActions(Node):\r\n    def __init__(self):\r\n        super().__init__('recovery_actions')\r\n\r\n        # Recovery action servers\r\n        self.backup_server = ActionServer(\r\n            self,\r\n            BackUp,\r\n            'backup',\r\n            self.backup_callback)\r\n\r\n        self.spin_server = ActionServer(\r\n            self,\r\n            Spin,\r\n            'spin',\r\n            self.spin_callback)\r\n\r\n        self.wait_server = ActionServer(\r\n            self,\r\n            Wait,\r\n            'wait',\r\n            self.wait_callback)\r\n\r\n    def backup_callback(self, goal_handle):\r\n        \"\"\"Execute backup recovery behavior\"\"\"\r\n        self.get_logger().info('Executing backup recovery')\r\n\r\n        # Create velocity publisher\r\n        cmd_pub = self.create_publisher(Twist, 'cmd_vel', 10)\r\n\r\n        # Backup parameters\r\n        backup_dist = goal_handle.request.target.x if hasattr(goal_handle.request.target, 'x') else 0.3\r\n        backup_speed = 0.1  # m/s\r\n        duration = backup_dist / backup_speed\r\n\r\n        # Execute backup\r\n        start_time = time.time()\r\n        while time.time() - start_time < duration and not goal_handle.is_cancel_requested:\r\n            cmd = Twist()\r\n            cmd.linear.x = -backup_speed\r\n            cmd_pub.publish(cmd)\r\n            time.sleep(0.05)  # 20 Hz\r\n\r\n        # Stop\r\n        stop_cmd = Twist()\r\n        cmd_pub.publish(stop_cmd)\r\n\r\n        if goal_handle.is_cancel_requested:\r\n            goal_handle.canceled()\r\n            return BackUp.Result()\r\n\r\n        goal_handle.succeed()\r\n        return BackUp.Result()\r\n\r\n    def spin_callback(self, goal_handle):\r\n        \"\"\"Execute spin recovery behavior\"\"\"\r\n        self.get_logger().info('Executing spin recovery')\r\n\r\n        cmd_pub = self.create_publisher(Twist, 'cmd_vel', 10)\r\n\r\n        # Spin parameters\r\n        angle_to_turn = goal_handle.request.target_theta if hasattr(goal_handle.request.target_theta, 'data') else 1.57  # 90 degrees\r\n        spin_speed = 0.5  # rad/s\r\n        duration = abs(angle_to_turn) / spin_speed\r\n\r\n        start_time = time.time()\r\n        direction = 1 if angle_to_turn > 0 else -1\r\n\r\n        while time.time() - start_time < duration and not goal_handle.is_cancel_requested:\r\n            cmd = Twist()\r\n            cmd.angular.z = spin_speed * direction\r\n            cmd_pub.publish(cmd)\r\n            time.sleep(0.05)\r\n\r\n        # Stop\r\n        stop_cmd = Twist()\r\n        cmd_pub.publish(stop_cmd)\r\n\r\n        if goal_handle.is_cancel_requested:\r\n            goal_handle.canceled()\r\n            return Spin.Result()\r\n\r\n        goal_handle.succeed()\r\n        return Spin.Result()\r\n\r\n    def wait_callback(self, goal_handle):\r\n        \"\"\"Execute wait recovery behavior\"\"\"\r\n        self.get_logger().info('Executing wait recovery')\r\n\r\n        wait_time = goal_handle.request.time.sec + goal_handle.request.time.nanosec * 1e-9\r\n\r\n        start_time = time.time()\r\n        while time.time() - start_time < wait_time and not goal_handle.is_cancel_requested:\r\n            time.sleep(0.1)\r\n\r\n        if goal_handle.is_cancel_requested:\r\n            goal_handle.canceled()\r\n            return Wait.Result()\r\n\r\n        goal_handle.succeed()\r\n        return Wait.Result()\n"})}),"\n",(0,a.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(e.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Configure and use Navigation2 for robot navigation"}),"\n",(0,a.jsx)(e.li,{children:"Implement global path planning algorithms"}),"\n",(0,a.jsx)(e.li,{children:"Develop local path following controllers"}),"\n",(0,a.jsx)(e.li,{children:"Integrate obstacle avoidance with navigation"}),"\n",(0,a.jsx)(e.li,{children:"Implement recovery behaviors for navigation failures"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"hands-on-exercise",children:"Hands-on Exercise"}),"\n",(0,a.jsx)(e.p,{children:"Create a complete navigation system that includes global path planning, local path following, and obstacle avoidance. Test the system in simulation with various obstacle configurations."}),"\n",(0,a.jsx)(e.admonition,{type:"tip",children:(0,a.jsxs)(e.p,{children:["Use ",(0,a.jsx)(e.code,{children:"rviz2"})," to visualize the navigation process, including the global plan, local plan, costmaps, and robot trajectory."]})}),"\n",(0,a.jsx)(e.admonition,{type:"note",children:(0,a.jsx)(e.p,{children:"Navigation2 performance depends heavily on accurate localization, so ensure your robot's localization system is properly configured before deploying navigation."})})]})}function d(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(_,{...n})}):_(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>i,x:()=>s});var t=r(6540);const a={},o=t.createContext(a);function i(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:i(n.components),t.createElement(o.Provider,{value:e},n.children)}}}]);