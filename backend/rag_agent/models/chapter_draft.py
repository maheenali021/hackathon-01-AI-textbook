"""
Chapter Draft Response Model for the Reusable Intelligence System
Defines the structure for chapter draft responses from the Chapter Author subagent
"""
from typing import Dict, Any, List
from datetime import datetime


class ChapterDraft:
    """
    Class representing a chapter draft generated by the Chapter Author subagent
    """

    def __init__(self, title: str, content: str, sections: List[Dict[str, Any]], metadata: Dict[str, Any]):
        self.id = f"chapter_{title.replace(' ', '_').replace('/', '_').lower()}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        self.title = title
        self.content = content
        self.sections = sections
        self.metadata = metadata
        self.created_at = datetime.now()
        self.updated_at = datetime.now()

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the chapter draft to a dictionary representation

        Returns:
            Dictionary representation of the chapter draft
        """
        return {
            "id": self.id,
            "title": self.title,
            "content": self.content,
            "sections": self.sections,
            "metadata": self.metadata,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat()
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ChapterDraft':
        """
        Create a ChapterDraft instance from a dictionary

        Args:
            data: Dictionary containing chapter draft data

        Returns:
            ChapterDraft instance
        """
        return cls(
            title=data["title"],
            content=data["content"],
            sections=data["sections"],
            metadata=data["metadata"]
        )

    def add_section(self, title: str, content: str) -> None:
        """
        Add a new section to the chapter draft

        Args:
            title: Title of the new section
            content: Content of the new section
        """
        new_section = {
            "title": title,
            "content": content,
            "word_count": len(content.split()),
            "created_at": datetime.now().isoformat()
        }
        self.sections.append(new_section)
        self.updated_at = datetime.now()

    def update_section(self, index: int, title: str = None, content: str = None) -> bool:
        """
        Update an existing section in the chapter draft

        Args:
            index: Index of the section to update
            title: New title for the section (optional)
            content: New content for the section (optional)

        Returns:
            Boolean indicating whether the update was successful
        """
        if 0 <= index < len(self.sections):
            if title is not None:
                self.sections[index]["title"] = title
            if content is not None:
                self.sections[index]["content"] = content
                self.sections[index]["word_count"] = len(content.split())
            self.sections[index]["updated_at"] = datetime.now().isoformat()
            self.updated_at = datetime.now()
            return True
        return False

    def get_section_by_title(self, title: str) -> Dict[str, Any]:
        """
        Get a section by its title

        Args:
            title: Title of the section to retrieve

        Returns:
            Dictionary containing the section data, or None if not found
        """
        for section in self.sections:
            if section["title"].lower() == title.lower():
                return section
        return None

    def get_word_count(self) -> int:
        """
        Get the total word count of the chapter

        Returns:
            Total word count
        """
        return len(self.content.split())

    def get_reading_time(self) -> int:
        """
        Estimate the reading time of the chapter (assuming 200 words per minute)

        Returns:
            Estimated reading time in minutes
        """
        return max(1, self.get_word_count() // 200)

    def validate_structure(self) -> Dict[str, Any]:
        """
        Validate the structure of the chapter draft

        Returns:
            Dictionary with validation results
        """
        validation_results = {
            "is_valid": True,
            "issues": [],
            "warnings": []
        }

        # Check if title is provided
        if not self.title or len(self.title.strip()) == 0:
            validation_results["is_valid"] = False
            validation_results["issues"].append("Chapter title is missing or empty")

        # Check if content is provided
        if not self.content or len(self.content.strip()) == 0:
            validation_results["is_valid"] = False
            validation_results["issues"].append("Chapter content is missing or empty")

        # Check if sections exist
        if not self.sections or len(self.sections) == 0:
            validation_results["warnings"].append("No sections defined in chapter")

        # Check if sections have required fields
        for i, section in enumerate(self.sections):
            if not isinstance(section, dict):
                validation_results["is_valid"] = False
                validation_results["issues"].append(f"Section at index {i} is not a dictionary")
                continue

            if "title" not in section or not section["title"]:
                validation_results["is_valid"] = False
                validation_results["issues"].append(f"Section at index {i} is missing title")

            if "content" not in section or not section["content"]:
                validation_results["is_valid"] = False
                validation_results["issues"].append(f"Section at index {i} is missing content")

        # Check metadata
        if not self.metadata:
            validation_results["warnings"].append("No metadata provided")

        return validation_results

    def get_summary(self) -> Dict[str, Any]:
        """
        Get a summary of the chapter draft

        Returns:
            Dictionary with key information about the chapter draft
        """
        return {
            "id": self.id,
            "title": self.title,
            "word_count": self.get_word_count(),
            "estimated_reading_time": self.get_reading_time(),
            "section_count": len(self.sections),
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "technical_accuracy_score": self.metadata.get("technical_accuracy_score", 0.0)
        }

    def merge_with(self, other_draft: 'ChapterDraft') -> 'ChapterDraft':
        """
        Merge this chapter draft with another one

        Args:
            other_draft: Another ChapterDraft to merge with

        Returns:
            New ChapterDraft instance with merged content
        """
        # Combine sections, preferring content from the other draft if titles match
        merged_sections = self.sections.copy()
        other_titles = {section["title"] for section in other_draft.sections}

        for other_section in other_draft.sections:
            # Check if a section with the same title already exists
            existing_idx = None
            for i, existing_section in enumerate(merged_sections):
                if existing_section["title"] == other_section["title"]:
                    existing_idx = i
                    break

            if existing_idx is not None:
                # Update existing section with other draft's content
                merged_sections[existing_idx] = other_section
            else:
                # Add new section
                merged_sections.append(other_section)

        # Combine content (could be more sophisticated)
        combined_content = f"{self.content}\n\n{other_draft.content}"

        # Combine metadata (prefer other's metadata if there are conflicts)
        combined_metadata = {**self.metadata, **other_draft.metadata}

        # Create new chapter draft with merged content
        merged_draft = ChapterDraft(
            title=f"{self.title} / {other_draft.title}",
            content=combined_content,
            sections=merged_sections,
            metadata=combined_metadata
        )

        return merged_draft