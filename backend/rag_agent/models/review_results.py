"""
Review Results Response Model for the Reusable Intelligence System
Defines the structure for review results from the Technical Reviewer subagent
"""
from typing import Dict, Any, List
from datetime import datetime


class ReviewResults:
    """
    Class representing review results generated by the Technical Reviewer subagent
    """

    def __init__(self, feedback: List[Dict[str, Any]], accuracy_score: float, suggestions: List[str], summary: Dict[str, Any]):
        self.id = f"review_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        self.feedback = feedback
        self.accuracy_score = accuracy_score
        self.suggestions = suggestions
        self.summary = summary
        self.created_at = datetime.now()
        self.updated_at = datetime.now()

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the review results to a dictionary representation

        Returns:
            Dictionary representation of the review results
        """
        return {
            "id": self.id,
            "feedback": self.feedback,
            "accuracy_score": self.accuracy_score,
            "suggestions": self.suggestions,
            "summary": self.summary,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat()
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ReviewResults':
        """
        Create a ReviewResults instance from a dictionary

        Args:
            data: Dictionary containing review results data

        Returns:
            ReviewResults instance
        """
        return cls(
            feedback=data["feedback"],
            accuracy_score=data["accuracy_score"],
            suggestions=data["suggestions"],
            summary=data["summary"]
        )

    def add_feedback(self, feedback_item: Dict[str, Any]) -> None:
        """
        Add a new feedback item to the review results

        Args:
            feedback_item: Dictionary containing feedback information
        """
        self.feedback.append(feedback_item)
        self.updated_at = datetime.now()

    def add_suggestion(self, suggestion: str) -> None:
        """
        Add a new suggestion to the review results

        Args:
            suggestion: Suggestion string to add
        """
        if suggestion not in self.suggestions:
            self.suggestions.append(suggestion)
            self.updated_at = datetime.now()

    def update_accuracy_score(self, new_score: float) -> None:
        """
        Update the accuracy score of the review

        Args:
            new_score: New accuracy score (between 0 and 1)
        """
        if 0 <= new_score <= 1:
            self.accuracy_score = new_score
            self.updated_at = datetime.now()
        else:
            raise ValueError("Accuracy score must be between 0 and 1")

    def get_severity_breakdown(self) -> Dict[str, int]:
        """
        Get a breakdown of feedback by severity

        Returns:
            Dictionary with counts for each severity level
        """
        severity_counts = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0
        }

        for feedback_item in self.feedback:
            severity = feedback_item.get("severity", "medium")
            if severity in severity_counts:
                severity_counts[severity] += 1

        return severity_counts

    def get_category_breakdown(self) -> Dict[str, int]:
        """
        Get a breakdown of feedback by category

        Returns:
            Dictionary with counts for each category
        """
        category_counts = {
            "technical": 0,
            "style": 0,
            "structure": 0,
            "accuracy": 0,
            "completeness": 0
        }

        for feedback_item in self.feedback:
            category = feedback_item.get("category", "other")
            if category in category_counts:
                category_counts[category] += 1

        return category_counts

    def get_type_breakdown(self) -> Dict[str, int]:
        """
        Get a breakdown of feedback by type

        Returns:
            Dictionary with counts for each type
        """
        type_counts = {
            "error": 0,
            "warning": 0,
            "suggestion": 0,
            "positive": 0
        }

        for feedback_item in self.feedback:
            feedback_type = feedback_item.get("type", "other")
            if feedback_type in type_counts:
                type_counts[feedback_type] += 1

        return type_counts

    def get_important_issues(self, min_severity: str = "high") -> List[Dict[str, Any]]:
        """
        Get feedback items with severity equal to or higher than the specified level

        Args:
            min_severity: Minimum severity level (default "high")

        Returns:
            List of feedback items with severity equal to or higher than specified
        """
        severity_hierarchy = {
            "low": 1,
            "medium": 2,
            "high": 3,
            "critical": 4
        }

        min_level = severity_hierarchy.get(min_severity, 3)

        important_issues = []
        for feedback_item in self.feedback:
            severity = feedback_item.get("severity", "medium")
            if severity_hierarchy.get(severity, 2) >= min_level:
                important_issues.append(feedback_item)

        return important_issues

    def validate_results(self) -> Dict[str, Any]:
        """
        Validate the structure of the review results

        Returns:
            Dictionary with validation results
        """
        validation_results = {
            "is_valid": True,
            "issues": [],
            "warnings": []
        }

        # Check accuracy score
        if not isinstance(self.accuracy_score, (int, float)) or not (0 <= self.accuracy_score <= 1):
            validation_results["is_valid"] = False
            validation_results["issues"].append("Accuracy score must be a number between 0 and 1")

        # Check feedback structure
        if not isinstance(self.feedback, list):
            validation_results["is_valid"] = False
            validation_results["issues"].append("Feedback must be a list")
        else:
            for i, item in enumerate(self.feedback):
                if not isinstance(item, dict):
                    validation_results["is_valid"] = False
                    validation_results["issues"].append(f"Feedback item at index {i} is not a dictionary")
                    continue

                required_fields = ["type", "category", "message", "severity"]
                for field in required_fields:
                    if field not in item:
                        validation_results["is_valid"] = False
                        validation_results["issues"].append(f"Feedback item at index {i} is missing required field: {field}")

        # Check suggestions
        if not isinstance(self.suggestions, list):
            validation_results["is_valid"] = False
            validation_results["issues"].append("Suggestions must be a list")

        # Check summary
        if not isinstance(self.summary, dict):
            validation_results["is_valid"] = False
            validation_results["issues"].append("Summary must be a dictionary")

        return validation_results

    def get_summary_stats(self) -> Dict[str, Any]:
        """
        Get statistical summary of the review results

        Returns:
            Dictionary with statistical summary
        """
        severity_breakdown = self.get_severity_breakdown()
        category_breakdown = self.get_category_breakdown()
        type_breakdown = self.get_type_breakdown()

        total_feedback = len(self.feedback)
        total_suggestions = len(self.suggestions)

        stats = {
            "accuracy_score": self.accuracy_score,
            "total_feedback_items": total_feedback,
            "total_suggestions": total_suggestions,
            "severity_breakdown": severity_breakdown,
            "category_breakdown": category_breakdown,
            "type_breakdown": type_breakdown,
            "feedback_per_suggestion_ratio": total_feedback / total_suggestions if total_suggestions > 0 else 0,
            "critical_issues_count": severity_breakdown["critical"],
            "high_severity_issues": severity_breakdown["high"],
            "created_at": self.created_at.isoformat()
        }

        return stats

    def merge_with(self, other_results: 'ReviewResults') -> 'ReviewResults':
        """
        Merge this review results with another one

        Args:
            other_results: Another ReviewResults to merge with

        Returns:
            New ReviewResults instance with merged feedback
        """
        # Combine feedback lists
        merged_feedback = self.feedback + other_results.feedback

        # Combine suggestions
        all_suggestions = list(set(self.suggestions + other_results.suggestions))

        # Calculate combined accuracy score (weighted average based on feedback count)
        total_feedback_self = len(self.feedback)
        total_feedback_other = len(other_results.feedback)
        total_feedback_combined = total_feedback_self + total_feedback_other

        if total_feedback_combined > 0:
            combined_accuracy = (
                (self.accuracy_score * total_feedback_self) +
                (other_results.accuracy_score * total_feedback_other)
            ) / total_feedback_combined
        else:
            combined_accuracy = 0.0

        # Combine summaries (prefer the newer one for conflicting fields)
        combined_summary = {**self.summary, **other_results.summary}

        # Create new review results with merged data
        merged_results = ReviewResults(
            feedback=merged_feedback,
            accuracy_score=combined_accuracy,
            suggestions=all_suggestions,
            summary=combined_summary
        )

        return merged_results

    def filter_by_category(self, categories: List[str]) -> 'ReviewResults':
        """
        Filter feedback by specified categories

        Args:
            categories: List of categories to include

        Returns:
            New ReviewResults instance with filtered feedback
        """
        filtered_feedback = [
            item for item in self.feedback
            if item.get("category") in categories
        ]

        # Create new results with filtered feedback
        filtered_results = ReviewResults(
            feedback=filtered_feedback,
            accuracy_score=self.accuracy_score,
            suggestions=self.suggestions,
            summary=self.summary
        )

        return filtered_results

    def filter_by_severity(self, min_severity: str = "medium") -> 'ReviewResults':
        """
        Filter feedback by minimum severity level

        Args:
            min_severity: Minimum severity level to include

        Returns:
            New ReviewResults instance with filtered feedback
        """
        severity_hierarchy = {
            "low": 1,
            "medium": 2,
            "high": 3,
            "critical": 4
        }

        min_level = severity_hierarchy.get(min_severity, 2)

        filtered_feedback = [
            item for item in self.feedback
            if severity_hierarchy.get(item.get("severity", "medium"), 2) >= min_level
        ]

        # Create new results with filtered feedback
        filtered_results = ReviewResults(
            feedback=filtered_feedback,
            accuracy_score=self.accuracy_score,
            suggestions=self.suggestions,
            summary=self.summary
        )

        return filtered_results